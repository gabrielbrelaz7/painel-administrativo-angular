{"ast":null,"code":"var NAMESPACE = require(\"./conventions\").NAMESPACE; //[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n//[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n//[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\n\n\nvar nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\n\nvar nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\nvar tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$'); //var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n\nvar S_TAG = 0; //tag name offerring\n\nvar S_ATTR = 1; //attr name offerring \n\nvar S_ATTR_SPACE = 2; //attr name end and space offer\n\nvar S_EQ = 3; //=space?\n\nvar S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\n\nvar S_ATTR_END = 5; //attr value end and no space(quot end)\n\nvar S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\n\nvar S_TAG_CLOSE = 7; //closed el<el />\n\n/**\n * Creates an error that will not be caught by XMLReader aka the SAX parser.\n *\n * @param {string} message\n * @param {any?} locator Optional, can provide details about the location in the source\n * @constructor\n */\n\nfunction ParseError(message, locator) {\n  this.message = message;\n  this.locator = locator;\n  if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);\n}\n\nParseError.prototype = new Error();\nParseError.prototype.name = ParseError.name;\n\nfunction XMLReader() {}\n\nXMLReader.prototype = {\n  parse: function parse(source, defaultNSMap, entityMap) {\n    var domBuilder = this.domBuilder;\n    domBuilder.startDocument();\n\n    _copy(defaultNSMap, defaultNSMap = {});\n\n    _parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n\n    domBuilder.endDocument();\n  }\n};\n\nfunction _parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n  function fixedFromCharCode(code) {\n    // String.prototype.fromCharCode does not supports\n    // > 2 bytes unicode chars directly\n    if (code > 0xffff) {\n      code -= 0x10000;\n      var surrogate1 = 0xd800 + (code >> 10),\n          surrogate2 = 0xdc00 + (code & 0x3ff);\n      return String.fromCharCode(surrogate1, surrogate2);\n    } else {\n      return String.fromCharCode(code);\n    }\n  }\n\n  function entityReplacer(a) {\n    var k = a.slice(1, -1);\n\n    if (k in entityMap) {\n      return entityMap[k];\n    } else if (k.charAt(0) === '#') {\n      return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\n    } else {\n      errorHandler.error('entity not found:' + a);\n      return a;\n    }\n  }\n\n  function appendText(end) {\n    //has some bugs\n    if (end > start) {\n      var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\n      locator && position(start);\n      domBuilder.characters(xt, 0, end - start);\n      start = end;\n    }\n  }\n\n  function position(p, m) {\n    while (p >= lineEnd && (m = linePattern.exec(source))) {\n      lineStart = m.index;\n      lineEnd = lineStart + m[0].length;\n      locator.lineNumber++; //console.log('line++:',locator,startPos,endPos)\n    }\n\n    locator.columnNumber = p - lineStart + 1;\n  }\n\n  var lineStart = 0;\n  var lineEnd = 0;\n  var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g;\n  var locator = domBuilder.locator;\n  var parseStack = [{\n    currentNSMap: defaultNSMapCopy\n  }];\n  var closeMap = {};\n  var start = 0;\n\n  while (true) {\n    try {\n      var tagStart = source.indexOf('<', start);\n\n      if (tagStart < 0) {\n        if (!source.substr(start).match(/^\\s*$/)) {\n          var doc = domBuilder.doc;\n          var text = doc.createTextNode(source.substr(start));\n          doc.appendChild(text);\n          domBuilder.currentElement = text;\n        }\n\n        return;\n      }\n\n      if (tagStart > start) {\n        appendText(tagStart);\n      }\n\n      switch (source.charAt(tagStart + 1)) {\n        case '/':\n          var end = source.indexOf('>', tagStart + 3);\n          var tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\n          var config = parseStack.pop();\n\n          if (end < 0) {\n            tagName = source.substring(tagStart + 2).replace(/[\\s<].*/, '');\n            errorHandler.error(\"end tag name: \" + tagName + ' is not complete:' + config.tagName);\n            end = tagStart + 1 + tagName.length;\n          } else if (tagName.match(/\\s</)) {\n            tagName = tagName.replace(/[\\s<].*/, '');\n            errorHandler.error(\"end tag name: \" + tagName + ' maybe not complete');\n            end = tagStart + 1 + tagName.length;\n          }\n\n          var localNSMap = config.localNSMap;\n          var endMatch = config.tagName == tagName;\n          var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();\n\n          if (endIgnoreCaseMach) {\n            domBuilder.endElement(config.uri, config.localName, tagName);\n\n            if (localNSMap) {\n              for (var prefix in localNSMap) {\n                if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n                  domBuilder.endPrefixMapping(prefix);\n                }\n              }\n            }\n\n            if (!endMatch) {\n              errorHandler.fatalError(\"end tag name: \" + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case\n            }\n          } else {\n            parseStack.push(config);\n          }\n\n          end++;\n          break;\n        // end elment\n\n        case '?':\n          // <?...?>\n          locator && position(tagStart);\n          end = parseInstruction(source, tagStart, domBuilder);\n          break;\n\n        case '!':\n          // <!doctype,<![CDATA,<!--\n          locator && position(tagStart);\n          end = parseDCC(source, tagStart, domBuilder, errorHandler);\n          break;\n\n        default:\n          locator && position(tagStart);\n          var el = new ElementAttributes();\n          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap; //elStartEnd\n\n          var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);\n          var len = el.length;\n\n          if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\n            el.closed = true;\n\n            if (!entityMap.nbsp) {\n              errorHandler.warning('unclosed xml attribute');\n            }\n          }\n\n          if (locator && len) {\n            var locator2 = copyLocator(locator, {}); //try{//attribute position fixed\n\n            for (var i = 0; i < len; i++) {\n              var a = el[i];\n              position(a.offset);\n              a.locator = copyLocator(locator, {});\n            }\n\n            domBuilder.locator = locator2;\n\n            if (appendElement(el, domBuilder, currentNSMap)) {\n              parseStack.push(el);\n            }\n\n            domBuilder.locator = locator;\n          } else {\n            if (appendElement(el, domBuilder, currentNSMap)) {\n              parseStack.push(el);\n            }\n          }\n\n          if (NAMESPACE.isHTML(el.uri) && !el.closed) {\n            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n          } else {\n            end++;\n          }\n\n      }\n    } catch (e) {\n      if (e instanceof ParseError) {\n        throw e;\n      }\n\n      errorHandler.error('element parse error: ' + e);\n      end = -1;\n    }\n\n    if (end > start) {\n      start = end;\n    } else {\n      //TODO: 这里有可能sax回退，有位置错误风险\n      appendText(Math.max(tagStart, start) + 1);\n    }\n  }\n}\n\nfunction copyLocator(f, t) {\n  t.lineNumber = f.lineNumber;\n  t.columnNumber = f.columnNumber;\n  return t;\n}\n/**\n * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\n */\n\n\nfunction parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {\n  /**\n   * @param {string} qname\n   * @param {string} value\n   * @param {number} startIndex\n   */\n  function addAttribute(qname, value, startIndex) {\n    if (el.attributeNames.hasOwnProperty(qname)) {\n      errorHandler.fatalError('Attribute ' + qname + ' redefined');\n    }\n\n    el.addValue(qname, value, startIndex);\n  }\n\n  var attrName;\n  var value;\n  var p = ++start;\n  var s = S_TAG; //status\n\n  while (true) {\n    var c = source.charAt(p);\n\n    switch (c) {\n      case '=':\n        if (s === S_ATTR) {\n          //attrName\n          attrName = source.slice(start, p);\n          s = S_EQ;\n        } else if (s === S_ATTR_SPACE) {\n          s = S_EQ;\n        } else {\n          //fatalError: equal must after attrName or space after attrName\n          throw new Error('attribute equal must after attrName'); // No known test case\n        }\n\n        break;\n\n      case '\\'':\n      case '\"':\n        if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n        ) {\n          //equal\n          if (s === S_ATTR) {\n            errorHandler.warning('attribute value must after \"=\"');\n            attrName = source.slice(start, p);\n          }\n\n          start = p + 1;\n          p = source.indexOf(c, start);\n\n          if (p > 0) {\n            value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n            addAttribute(attrName, value, start - 1);\n            s = S_ATTR_END;\n          } else {\n            //fatalError: no end quot match\n            throw new Error('attribute value no end \\'' + c + '\\' match');\n          }\n        } else if (s == S_ATTR_NOQUOT_VALUE) {\n          value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer); //console.log(attrName,value,start,p)\n\n          addAttribute(attrName, value, start); //console.dir(el)\n\n          errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n          start = p + 1;\n          s = S_ATTR_END;\n        } else {\n          //fatalError: no equal before\n          throw new Error('attribute value must after \"=\"'); // No known test case\n        }\n\n        break;\n\n      case '/':\n        switch (s) {\n          case S_TAG:\n            el.setTagName(source.slice(start, p));\n\n          case S_ATTR_END:\n          case S_TAG_SPACE:\n          case S_TAG_CLOSE:\n            s = S_TAG_CLOSE;\n            el.closed = true;\n\n          case S_ATTR_NOQUOT_VALUE:\n          case S_ATTR:\n          case S_ATTR_SPACE:\n            break;\n          //case S_EQ:\n\n          default:\n            throw new Error(\"attribute invalid close char('/')\");\n          // No known test case\n        }\n\n        break;\n\n      case '':\n        //end document\n        errorHandler.error('unexpected end of input');\n\n        if (s == S_TAG) {\n          el.setTagName(source.slice(start, p));\n        }\n\n        return p;\n\n      case '>':\n        switch (s) {\n          case S_TAG:\n            el.setTagName(source.slice(start, p));\n\n          case S_ATTR_END:\n          case S_TAG_SPACE:\n          case S_TAG_CLOSE:\n            break;\n          //normal\n\n          case S_ATTR_NOQUOT_VALUE: //Compatible state\n\n          case S_ATTR:\n            value = source.slice(start, p);\n\n            if (value.slice(-1) === '/') {\n              el.closed = true;\n              value = value.slice(0, -1);\n            }\n\n          case S_ATTR_SPACE:\n            if (s === S_ATTR_SPACE) {\n              value = attrName;\n            }\n\n            if (s == S_ATTR_NOQUOT_VALUE) {\n              errorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\n              addAttribute(attrName, value.replace(/&#?\\w+;/g, entityReplacer), start);\n            } else {\n              if (!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {\n                errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n              }\n\n              addAttribute(value, value, start);\n            }\n\n            break;\n\n          case S_EQ:\n            throw new Error('attribute value missed!!');\n        } //\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n\n\n        return p;\n\n      /*xml space '\\x20' | #x9 | #xD | #xA; */\n\n      case \"\\x80\":\n        c = ' ';\n\n      default:\n        if (c <= ' ') {\n          //space\n          switch (s) {\n            case S_TAG:\n              el.setTagName(source.slice(start, p)); //tagName\n\n              s = S_TAG_SPACE;\n              break;\n\n            case S_ATTR:\n              attrName = source.slice(start, p);\n              s = S_ATTR_SPACE;\n              break;\n\n            case S_ATTR_NOQUOT_VALUE:\n              var value = source.slice(start, p).replace(/&#?\\w+;/g, entityReplacer);\n              errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n              addAttribute(attrName, value, start);\n\n            case S_ATTR_END:\n              s = S_TAG_SPACE;\n              break;\n            //case S_TAG_SPACE:\n            //case S_EQ:\n            //case S_ATTR_SPACE:\n            //\tvoid();break;\n            //case S_TAG_CLOSE:\n            //ignore warning\n          }\n        } else {\n          //not space\n          //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n          //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n          switch (s) {\n            //case S_TAG:void();break;\n            //case S_ATTR:void();break;\n            //case S_ATTR_NOQUOT_VALUE:void();break;\n            case S_ATTR_SPACE:\n              var tagName = el.tagName;\n\n              if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n                errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n              }\n\n              addAttribute(attrName, attrName, start);\n              start = p;\n              s = S_ATTR;\n              break;\n\n            case S_ATTR_END:\n              errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n\n            case S_TAG_SPACE:\n              s = S_ATTR;\n              start = p;\n              break;\n\n            case S_EQ:\n              s = S_ATTR_NOQUOT_VALUE;\n              start = p;\n              break;\n\n            case S_TAG_CLOSE:\n              throw new Error(\"elements closed character '/' and '>' must be connected to\");\n          }\n        }\n\n    } //end outer switch\n    //console.log('p++',p)\n\n\n    p++;\n  }\n}\n/**\n * @return true if has new namespace define\n */\n\n\nfunction appendElement(el, domBuilder, currentNSMap) {\n  var tagName = el.tagName;\n  var localNSMap = null; //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n\n  var i = el.length;\n\n  while (i--) {\n    var a = el[i];\n    var qName = a.qName;\n    var value = a.value;\n    var nsp = qName.indexOf(':');\n\n    if (nsp > 0) {\n      var prefix = a.prefix = qName.slice(0, nsp);\n      var localName = qName.slice(nsp + 1);\n      var nsPrefix = prefix === 'xmlns' && localName;\n    } else {\n      localName = qName;\n      prefix = null;\n      nsPrefix = qName === 'xmlns' && '';\n    } //can not set prefix,because prefix !== ''\n\n\n    a.localName = localName; //prefix == null for no ns prefix attribute \n\n    if (nsPrefix !== false) {\n      //hack!!\n      if (localNSMap == null) {\n        localNSMap = {}; //console.log(currentNSMap,0)\n\n        _copy(currentNSMap, currentNSMap = {}); //console.log(currentNSMap,1)\n\n      }\n\n      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n      a.uri = NAMESPACE.XMLNS;\n      domBuilder.startPrefixMapping(nsPrefix, value);\n    }\n  }\n\n  var i = el.length;\n\n  while (i--) {\n    a = el[i];\n    var prefix = a.prefix;\n\n    if (prefix) {\n      //no prefix attribute has no namespace\n      if (prefix === 'xml') {\n        a.uri = NAMESPACE.XML;\n      }\n\n      if (prefix !== 'xmlns') {\n        a.uri = currentNSMap[prefix || '']; //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n      }\n    }\n  }\n\n  var nsp = tagName.indexOf(':');\n\n  if (nsp > 0) {\n    prefix = el.prefix = tagName.slice(0, nsp);\n    localName = el.localName = tagName.slice(nsp + 1);\n  } else {\n    prefix = null; //important!!\n\n    localName = el.localName = tagName;\n  } //no prefix element has default namespace\n\n\n  var ns = el.uri = currentNSMap[prefix || ''];\n  domBuilder.startElement(ns, localName, tagName, el); //endPrefixMapping and startPrefixMapping have not any help for dom builder\n  //localNSMap = null\n\n  if (el.closed) {\n    domBuilder.endElement(ns, localName, tagName);\n\n    if (localNSMap) {\n      for (prefix in localNSMap) {\n        if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n          domBuilder.endPrefixMapping(prefix);\n        }\n      }\n    }\n  } else {\n    el.currentNSMap = currentNSMap;\n    el.localNSMap = localNSMap; //parseStack.push(el);\n\n    return true;\n  }\n}\n\nfunction parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n  if (/^(?:script|textarea)$/i.test(tagName)) {\n    var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n    var text = source.substring(elStartEnd + 1, elEndStart);\n\n    if (/[&<]/.test(text)) {\n      if (/^script$/i.test(tagName)) {\n        //if(!/\\]\\]>/.test(text)){\n        //lexHandler.startCDATA();\n        domBuilder.characters(text, 0, text.length); //lexHandler.endCDATA();\n\n        return elEndStart; //}\n      } //}else{//text area\n\n\n      text = text.replace(/&#?\\w+;/g, entityReplacer);\n      domBuilder.characters(text, 0, text.length);\n      return elEndStart; //}\n    }\n  }\n\n  return elStartEnd + 1;\n}\n\nfunction fixSelfClosed(source, elStartEnd, tagName, closeMap) {\n  //if(tagName in closeMap){\n  var pos = closeMap[tagName];\n\n  if (pos == null) {\n    //console.log(tagName)\n    pos = source.lastIndexOf('</' + tagName + '>');\n\n    if (pos < elStartEnd) {\n      //忘记闭合\n      pos = source.lastIndexOf('</' + tagName);\n    }\n\n    closeMap[tagName] = pos;\n  }\n\n  return pos < elStartEnd; //} \n}\n\nfunction _copy(source, target) {\n  for (var n in source) {\n    if (Object.prototype.hasOwnProperty.call(source, n)) {\n      target[n] = source[n];\n    }\n  }\n}\n\nfunction parseDCC(source, start, domBuilder, errorHandler) {\n  //sure start with '<!'\n  var next = source.charAt(start + 2);\n\n  switch (next) {\n    case '-':\n      if (source.charAt(start + 3) === '-') {\n        var end = source.indexOf('-->', start + 4); //append comment source.substring(4,end)//<!--\n\n        if (end > start) {\n          domBuilder.comment(source, start + 4, end - start - 4);\n          return end + 3;\n        } else {\n          errorHandler.error(\"Unclosed comment\");\n          return -1;\n        }\n      } else {\n        //error\n        return -1;\n      }\n\n    default:\n      if (source.substr(start + 3, 6) == 'CDATA[') {\n        var end = source.indexOf(']]>', start + 9);\n        domBuilder.startCDATA();\n        domBuilder.characters(source, start + 9, end - start - 9);\n        domBuilder.endCDATA();\n        return end + 3;\n      } //<!DOCTYPE\n      //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \n\n\n      var matchs = split(source, start);\n      var len = matchs.length;\n\n      if (len > 1 && /!doctype/i.test(matchs[0][0])) {\n        var name = matchs[1][0];\n        var pubid = false;\n        var sysid = false;\n\n        if (len > 3) {\n          if (/^public$/i.test(matchs[2][0])) {\n            pubid = matchs[3][0];\n            sysid = len > 4 && matchs[4][0];\n          } else if (/^system$/i.test(matchs[2][0])) {\n            sysid = matchs[3][0];\n          }\n        }\n\n        var lastMatch = matchs[len - 1];\n        domBuilder.startDTD(name, pubid, sysid);\n        domBuilder.endDTD();\n        return lastMatch.index + lastMatch[0].length;\n      }\n\n  }\n\n  return -1;\n}\n\nfunction parseInstruction(source, start, domBuilder) {\n  var end = source.indexOf('?>', start);\n\n  if (end) {\n    var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n\n    if (match) {\n      var len = match[0].length;\n      domBuilder.processingInstruction(match[1], match[2]);\n      return end + 2;\n    } else {\n      //error\n      return -1;\n    }\n  }\n\n  return -1;\n}\n\nfunction ElementAttributes() {\n  this.attributeNames = {};\n}\n\nElementAttributes.prototype = {\n  setTagName: function setTagName(tagName) {\n    if (!tagNamePattern.test(tagName)) {\n      throw new Error('invalid tagName:' + tagName);\n    }\n\n    this.tagName = tagName;\n  },\n  addValue: function addValue(qName, value, offset) {\n    if (!tagNamePattern.test(qName)) {\n      throw new Error('invalid attribute:' + qName);\n    }\n\n    this.attributeNames[qName] = this.length;\n    this[this.length++] = {\n      qName: qName,\n      value: value,\n      offset: offset\n    };\n  },\n  length: 0,\n  getLocalName: function getLocalName(i) {\n    return this[i].localName;\n  },\n  getLocator: function getLocator(i) {\n    return this[i].locator;\n  },\n  getQName: function getQName(i) {\n    return this[i].qName;\n  },\n  getURI: function getURI(i) {\n    return this[i].uri;\n  },\n  getValue: function getValue(i) {\n    return this[i].value;\n  } //\t,getIndex:function(uri, localName)){\n  //\t\tif(localName){\n  //\t\t\t\n  //\t\t}else{\n  //\t\t\tvar qName = uri\n  //\t\t}\n  //\t},\n  //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n  //\tgetType:function(uri,localName){}\n  //\tgetType:function(i){},\n\n};\n\nfunction split(source, start) {\n  var match;\n  var buf = [];\n  var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n  reg.lastIndex = start;\n  reg.exec(source); //skip <\n\n  while (match = reg.exec(source)) {\n    buf.push(match);\n    if (match[1]) return buf;\n  }\n}\n\nexports.XMLReader = XMLReader;\nexports.ParseError = ParseError;","map":{"version":3,"sources":["/home/multiplier/Documentos/Gabriel Brelaz/painel-angular-gabrielbrelaz.com/node_modules/@xmldom/xmldom/lib/sax.js"],"names":["NAMESPACE","require","nameStartChar","nameChar","RegExp","source","slice","tagNamePattern","S_TAG","S_ATTR","S_ATTR_SPACE","S_EQ","S_ATTR_NOQUOT_VALUE","S_ATTR_END","S_TAG_SPACE","S_TAG_CLOSE","ParseError","message","locator","Error","captureStackTrace","prototype","name","XMLReader","parse","defaultNSMap","entityMap","domBuilder","startDocument","_copy","errorHandler","endDocument","defaultNSMapCopy","fixedFromCharCode","code","surrogate1","surrogate2","String","fromCharCode","entityReplacer","a","k","charAt","parseInt","substr","replace","error","appendText","end","start","xt","substring","position","characters","p","m","lineEnd","linePattern","exec","lineStart","index","length","lineNumber","columnNumber","parseStack","currentNSMap","closeMap","tagStart","indexOf","match","doc","text","createTextNode","appendChild","currentElement","tagName","config","pop","localNSMap","endMatch","endIgnoreCaseMach","toLowerCase","endElement","uri","localName","prefix","Object","hasOwnProperty","call","endPrefixMapping","fatalError","push","parseInstruction","parseDCC","el","ElementAttributes","parseElementStartPart","len","closed","fixSelfClosed","nbsp","warning","locator2","copyLocator","i","offset","appendElement","isHTML","parseHtmlSpecialContent","e","Math","max","f","t","addAttribute","qname","value","startIndex","attributeNames","addValue","attrName","s","c","setTagName","qName","nsp","nsPrefix","XMLNS","startPrefixMapping","XML","ns","startElement","elStartEnd","test","elEndStart","pos","lastIndexOf","target","n","next","comment","startCDATA","endCDATA","matchs","split","pubid","sysid","lastMatch","startDTD","endDTD","processingInstruction","getLocalName","getLocator","getQName","getURI","getValue","buf","reg","lastIndex","exports"],"mappings":"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","sourcesContent":["var NAMESPACE = require(\"./conventions\").NAMESPACE;\n\n//[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n//[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n//[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\nvar nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]///\\u10000-\\uEFFFF\nvar nameChar = new RegExp(\"[\\\\-\\\\.0-9\"+nameStartChar.source.slice(1,-1)+\"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\nvar tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\\:'+nameStartChar.source+nameChar.source+'*)?$');\n//var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\nvar S_TAG = 0;//tag name offerring\nvar S_ATTR = 1;//attr name offerring \nvar S_ATTR_SPACE=2;//attr name end and space offer\nvar S_EQ = 3;//=space?\nvar S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)\nvar S_ATTR_END = 5;//attr value end and no space(quot end)\nvar S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)\nvar S_TAG_CLOSE = 7;//closed el<el />\n\n/**\n * Creates an error that will not be caught by XMLReader aka the SAX parser.\n *\n * @param {string} message\n * @param {any?} locator Optional, can provide details about the location in the source\n * @constructor\n */\nfunction ParseError(message, locator) {\n\tthis.message = message\n\tthis.locator = locator\n\tif(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);\n}\nParseError.prototype = new Error();\nParseError.prototype.name = ParseError.name\n\nfunction XMLReader(){\n\t\n}\n\nXMLReader.prototype = {\n\tparse:function(source,defaultNSMap,entityMap){\n\t\tvar domBuilder = this.domBuilder;\n\t\tdomBuilder.startDocument();\n\t\t_copy(defaultNSMap ,defaultNSMap = {})\n\t\tparse(source,defaultNSMap,entityMap,\n\t\t\t\tdomBuilder,this.errorHandler);\n\t\tdomBuilder.endDocument();\n\t}\n}\nfunction parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){\n\tfunction fixedFromCharCode(code) {\n\t\t// String.prototype.fromCharCode does not supports\n\t\t// > 2 bytes unicode chars directly\n\t\tif (code > 0xffff) {\n\t\t\tcode -= 0x10000;\n\t\t\tvar surrogate1 = 0xd800 + (code >> 10)\n\t\t\t\t, surrogate2 = 0xdc00 + (code & 0x3ff);\n\n\t\t\treturn String.fromCharCode(surrogate1, surrogate2);\n\t\t} else {\n\t\t\treturn String.fromCharCode(code);\n\t\t}\n\t}\n\tfunction entityReplacer(a){\n\t\tvar k = a.slice(1,-1);\n\t\tif(k in entityMap){\n\t\t\treturn entityMap[k]; \n\t\t}else if(k.charAt(0) === '#'){\n\t\t\treturn fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))\n\t\t}else{\n\t\t\terrorHandler.error('entity not found:'+a);\n\t\t\treturn a;\n\t\t}\n\t}\n\tfunction appendText(end){//has some bugs\n\t\tif(end>start){\n\t\t\tvar xt = source.substring(start,end).replace(/&#?\\w+;/g,entityReplacer);\n\t\t\tlocator&&position(start);\n\t\t\tdomBuilder.characters(xt,0,end-start);\n\t\t\tstart = end\n\t\t}\n\t}\n\tfunction position(p,m){\n\t\twhile(p>=lineEnd && (m = linePattern.exec(source))){\n\t\t\tlineStart = m.index;\n\t\t\tlineEnd = lineStart + m[0].length;\n\t\t\tlocator.lineNumber++;\n\t\t\t//console.log('line++:',locator,startPos,endPos)\n\t\t}\n\t\tlocator.columnNumber = p-lineStart+1;\n\t}\n\tvar lineStart = 0;\n\tvar lineEnd = 0;\n\tvar linePattern = /.*(?:\\r\\n?|\\n)|.*$/g\n\tvar locator = domBuilder.locator;\n\t\n\tvar parseStack = [{currentNSMap:defaultNSMapCopy}]\n\tvar closeMap = {};\n\tvar start = 0;\n\twhile(true){\n\t\ttry{\n\t\t\tvar tagStart = source.indexOf('<',start);\n\t\t\tif(tagStart<0){\n\t\t\t\tif(!source.substr(start).match(/^\\s*$/)){\n\t\t\t\t\tvar doc = domBuilder.doc;\n\t    \t\t\tvar text = doc.createTextNode(source.substr(start));\n\t    \t\t\tdoc.appendChild(text);\n\t    \t\t\tdomBuilder.currentElement = text;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(tagStart>start){\n\t\t\t\tappendText(tagStart);\n\t\t\t}\n\t\t\tswitch(source.charAt(tagStart+1)){\n\t\t\tcase '/':\n\t\t\t\tvar end = source.indexOf('>',tagStart+3);\n\t\t\t\tvar tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\n\t\t\t\tvar config = parseStack.pop();\n\t\t\t\tif(end<0){\n\t\t\t\t\t\n\t        \t\ttagName = source.substring(tagStart+2).replace(/[\\s<].*/,'');\n\t        \t\terrorHandler.error(\"end tag name: \"+tagName+' is not complete:'+config.tagName);\n\t        \t\tend = tagStart+1+tagName.length;\n\t        \t}else if(tagName.match(/\\s</)){\n\t        \t\ttagName = tagName.replace(/[\\s<].*/,'');\n\t        \t\terrorHandler.error(\"end tag name: \"+tagName+' maybe not complete');\n\t        \t\tend = tagStart+1+tagName.length;\n\t\t\t\t}\n\t\t\t\tvar localNSMap = config.localNSMap;\n\t\t\t\tvar endMatch = config.tagName == tagName;\n\t\t\t\tvar endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()\n\t\t        if(endIgnoreCaseMach){\n\t\t        \tdomBuilder.endElement(config.uri,config.localName,tagName);\n\t\t\t\t\tif(localNSMap){\n\t\t\t\t\t\tfor(var prefix in localNSMap) {\n\t\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n\t\t\t\t\t\t\t\tdomBuilder.endPrefixMapping(prefix);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!endMatch){\n\t\t            \terrorHandler.fatalError(\"end tag name: \"+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case\n\t\t\t\t\t}\n\t\t        }else{\n\t\t        \tparseStack.push(config)\n\t\t        }\n\t\t\t\t\n\t\t\t\tend++;\n\t\t\t\tbreak;\n\t\t\t\t// end elment\n\t\t\tcase '?':// <?...?>\n\t\t\t\tlocator&&position(tagStart);\n\t\t\t\tend = parseInstruction(source,tagStart,domBuilder);\n\t\t\t\tbreak;\n\t\t\tcase '!':// <!doctype,<![CDATA,<!--\n\t\t\t\tlocator&&position(tagStart);\n\t\t\t\tend = parseDCC(source,tagStart,domBuilder,errorHandler);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlocator&&position(tagStart);\n\t\t\t\tvar el = new ElementAttributes();\n\t\t\t\tvar currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n\t\t\t\t//elStartEnd\n\t\t\t\tvar end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);\n\t\t\t\tvar len = el.length;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){\n\t\t\t\t\tel.closed = true;\n\t\t\t\t\tif(!entityMap.nbsp){\n\t\t\t\t\t\terrorHandler.warning('unclosed xml attribute');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(locator && len){\n\t\t\t\t\tvar locator2 = copyLocator(locator,{});\n\t\t\t\t\t//try{//attribute position fixed\n\t\t\t\t\tfor(var i = 0;i<len;i++){\n\t\t\t\t\t\tvar a = el[i];\n\t\t\t\t\t\tposition(a.offset);\n\t\t\t\t\t\ta.locator = copyLocator(locator,{});\n\t\t\t\t\t}\n\t\t\t\t\tdomBuilder.locator = locator2\n\t\t\t\t\tif(appendElement(el,domBuilder,currentNSMap)){\n\t\t\t\t\t\tparseStack.push(el)\n\t\t\t\t\t}\n\t\t\t\t\tdomBuilder.locator = locator;\n\t\t\t\t}else{\n\t\t\t\t\tif(appendElement(el,domBuilder,currentNSMap)){\n\t\t\t\t\t\tparseStack.push(el)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (NAMESPACE.isHTML(el.uri) && !el.closed) {\n\t\t\t\t\tend = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)\n\t\t\t\t} else {\n\t\t\t\t\tend++;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tif (e instanceof ParseError) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\terrorHandler.error('element parse error: '+e)\n\t\t\tend = -1;\n\t\t}\n\t\tif(end>start){\n\t\t\tstart = end;\n\t\t}else{\n\t\t\t//TODO: 这里有可能sax回退，有位置错误风险\n\t\t\tappendText(Math.max(tagStart,start)+1);\n\t\t}\n\t}\n}\nfunction copyLocator(f,t){\n\tt.lineNumber = f.lineNumber;\n\tt.columnNumber = f.columnNumber;\n\treturn t;\n}\n\n/**\n * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\n */\nfunction parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){\n\n\t/**\n\t * @param {string} qname\n\t * @param {string} value\n\t * @param {number} startIndex\n\t */\n\tfunction addAttribute(qname, value, startIndex) {\n\t\tif (el.attributeNames.hasOwnProperty(qname)) {\n\t\t\terrorHandler.fatalError('Attribute ' + qname + ' redefined')\n\t\t}\n\t\tel.addValue(qname, value, startIndex)\n\t}\n\tvar attrName;\n\tvar value;\n\tvar p = ++start;\n\tvar s = S_TAG;//status\n\twhile(true){\n\t\tvar c = source.charAt(p);\n\t\tswitch(c){\n\t\tcase '=':\n\t\t\tif(s === S_ATTR){//attrName\n\t\t\t\tattrName = source.slice(start,p);\n\t\t\t\ts = S_EQ;\n\t\t\t}else if(s === S_ATTR_SPACE){\n\t\t\t\ts = S_EQ;\n\t\t\t}else{\n\t\t\t\t//fatalError: equal must after attrName or space after attrName\n\t\t\t\tthrow new Error('attribute equal must after attrName'); // No known test case\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tif(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n\t\t\t\t){//equal\n\t\t\t\tif(s === S_ATTR){\n\t\t\t\t\terrorHandler.warning('attribute value must after \"=\"')\n\t\t\t\t\tattrName = source.slice(start,p)\n\t\t\t\t}\n\t\t\t\tstart = p+1;\n\t\t\t\tp = source.indexOf(c,start)\n\t\t\t\tif(p>0){\n\t\t\t\t\tvalue = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\n\t\t\t\t\taddAttribute(attrName, value, start-1);\n\t\t\t\t\ts = S_ATTR_END;\n\t\t\t\t}else{\n\t\t\t\t\t//fatalError: no end quot match\n\t\t\t\t\tthrow new Error('attribute value no end \\''+c+'\\' match');\n\t\t\t\t}\n\t\t\t}else if(s == S_ATTR_NOQUOT_VALUE){\n\t\t\t\tvalue = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\n\t\t\t\t//console.log(attrName,value,start,p)\n\t\t\t\taddAttribute(attrName, value, start);\n\t\t\t\t//console.dir(el)\n\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed start quot('+c+')!!');\n\t\t\t\tstart = p+1;\n\t\t\t\ts = S_ATTR_END\n\t\t\t}else{\n\t\t\t\t//fatalError: no equal before\n\t\t\t\tthrow new Error('attribute value must after \"=\"'); // No known test case\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tswitch(s){\n\t\t\tcase S_TAG:\n\t\t\t\tel.setTagName(source.slice(start,p));\n\t\t\tcase S_ATTR_END:\n\t\t\tcase S_TAG_SPACE:\n\t\t\tcase S_TAG_CLOSE:\n\t\t\t\ts =S_TAG_CLOSE;\n\t\t\t\tel.closed = true;\n\t\t\tcase S_ATTR_NOQUOT_VALUE:\n\t\t\tcase S_ATTR:\n\t\t\tcase S_ATTR_SPACE:\n\t\t\t\tbreak;\n\t\t\t//case S_EQ:\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"attribute invalid close char('/')\") // No known test case\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ''://end document\n\t\t\terrorHandler.error('unexpected end of input');\n\t\t\tif(s == S_TAG){\n\t\t\t\tel.setTagName(source.slice(start,p));\n\t\t\t}\n\t\t\treturn p;\n\t\tcase '>':\n\t\t\tswitch(s){\n\t\t\tcase S_TAG:\n\t\t\t\tel.setTagName(source.slice(start,p));\n\t\t\tcase S_ATTR_END:\n\t\t\tcase S_TAG_SPACE:\n\t\t\tcase S_TAG_CLOSE:\n\t\t\t\tbreak;//normal\n\t\t\tcase S_ATTR_NOQUOT_VALUE://Compatible state\n\t\t\tcase S_ATTR:\n\t\t\t\tvalue = source.slice(start,p);\n\t\t\t\tif(value.slice(-1) === '/'){\n\t\t\t\t\tel.closed  = true;\n\t\t\t\t\tvalue = value.slice(0,-1)\n\t\t\t\t}\n\t\t\tcase S_ATTR_SPACE:\n\t\t\t\tif(s === S_ATTR_SPACE){\n\t\t\t\t\tvalue = attrName;\n\t\t\t\t}\n\t\t\t\tif(s == S_ATTR_NOQUOT_VALUE){\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!');\n\t\t\t\t\taddAttribute(attrName, value.replace(/&#?\\w+;/g,entityReplacer), start)\n\t\t\t\t}else{\n\t\t\t\t\tif(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){\n\t\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed value!! \"'+value+'\" instead!!')\n\t\t\t\t\t}\n\t\t\t\t\taddAttribute(value, value, start)\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase S_EQ:\n\t\t\t\tthrow new Error('attribute value missed!!');\n\t\t\t}\n//\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n\t\t\treturn p;\n\t\t/*xml space '\\x20' | #x9 | #xD | #xA; */\n\t\tcase '\\u0080':\n\t\t\tc = ' ';\n\t\tdefault:\n\t\t\tif(c<= ' '){//space\n\t\t\t\tswitch(s){\n\t\t\t\tcase S_TAG:\n\t\t\t\t\tel.setTagName(source.slice(start,p));//tagName\n\t\t\t\t\ts = S_TAG_SPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR:\n\t\t\t\t\tattrName = source.slice(start,p)\n\t\t\t\t\ts = S_ATTR_SPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR_NOQUOT_VALUE:\n\t\t\t\t\tvar value = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!!');\n\t\t\t\t\taddAttribute(attrName, value, start)\n\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\ts = S_TAG_SPACE;\n\t\t\t\t\tbreak;\n\t\t\t\t//case S_TAG_SPACE:\n\t\t\t\t//case S_EQ:\n\t\t\t\t//case S_ATTR_SPACE:\n\t\t\t\t//\tvoid();break;\n\t\t\t\t//case S_TAG_CLOSE:\n\t\t\t\t\t//ignore warning\n\t\t\t\t}\n\t\t\t}else{//not space\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n\t\t\t\tswitch(s){\n\t\t\t\t//case S_TAG:void();break;\n\t\t\t\t//case S_ATTR:void();break;\n\t\t\t\t//case S_ATTR_NOQUOT_VALUE:void();break;\n\t\t\t\tcase S_ATTR_SPACE:\n\t\t\t\t\tvar tagName =  el.tagName;\n\t\t\t\t\tif (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n\t\t\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed value!! \"'+attrName+'\" instead2!!')\n\t\t\t\t\t}\n\t\t\t\t\taddAttribute(attrName, attrName, start);\n\t\t\t\t\tstart = p;\n\t\t\t\t\ts = S_ATTR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_ATTR_END:\n\t\t\t\t\terrorHandler.warning('attribute space is required\"'+attrName+'\"!!')\n\t\t\t\tcase S_TAG_SPACE:\n\t\t\t\t\ts = S_ATTR;\n\t\t\t\t\tstart = p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_EQ:\n\t\t\t\t\ts = S_ATTR_NOQUOT_VALUE;\n\t\t\t\t\tstart = p;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S_TAG_CLOSE:\n\t\t\t\t\tthrow new Error(\"elements closed character '/' and '>' must be connected to\");\n\t\t\t\t}\n\t\t\t}\n\t\t}//end outer switch\n\t\t//console.log('p++',p)\n\t\tp++;\n\t}\n}\n/**\n * @return true if has new namespace define\n */\nfunction appendElement(el,domBuilder,currentNSMap){\n\tvar tagName = el.tagName;\n\tvar localNSMap = null;\n\t//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n\tvar i = el.length;\n\twhile(i--){\n\t\tvar a = el[i];\n\t\tvar qName = a.qName;\n\t\tvar value = a.value;\n\t\tvar nsp = qName.indexOf(':');\n\t\tif(nsp>0){\n\t\t\tvar prefix = a.prefix = qName.slice(0,nsp);\n\t\t\tvar localName = qName.slice(nsp+1);\n\t\t\tvar nsPrefix = prefix === 'xmlns' && localName\n\t\t}else{\n\t\t\tlocalName = qName;\n\t\t\tprefix = null\n\t\t\tnsPrefix = qName === 'xmlns' && ''\n\t\t}\n\t\t//can not set prefix,because prefix !== ''\n\t\ta.localName = localName ;\n\t\t//prefix == null for no ns prefix attribute \n\t\tif(nsPrefix !== false){//hack!!\n\t\t\tif(localNSMap == null){\n\t\t\t\tlocalNSMap = {}\n\t\t\t\t//console.log(currentNSMap,0)\n\t\t\t\t_copy(currentNSMap,currentNSMap={})\n\t\t\t\t//console.log(currentNSMap,1)\n\t\t\t}\n\t\t\tcurrentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n\t\t\ta.uri = NAMESPACE.XMLNS\n\t\t\tdomBuilder.startPrefixMapping(nsPrefix, value) \n\t\t}\n\t}\n\tvar i = el.length;\n\twhile(i--){\n\t\ta = el[i];\n\t\tvar prefix = a.prefix;\n\t\tif(prefix){//no prefix attribute has no namespace\n\t\t\tif(prefix === 'xml'){\n\t\t\t\ta.uri = NAMESPACE.XML;\n\t\t\t}if(prefix !== 'xmlns'){\n\t\t\t\ta.uri = currentNSMap[prefix || '']\n\t\t\t\t\n\t\t\t\t//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n\t\t\t}\n\t\t}\n\t}\n\tvar nsp = tagName.indexOf(':');\n\tif(nsp>0){\n\t\tprefix = el.prefix = tagName.slice(0,nsp);\n\t\tlocalName = el.localName = tagName.slice(nsp+1);\n\t}else{\n\t\tprefix = null;//important!!\n\t\tlocalName = el.localName = tagName;\n\t}\n\t//no prefix element has default namespace\n\tvar ns = el.uri = currentNSMap[prefix || ''];\n\tdomBuilder.startElement(ns,localName,tagName,el);\n\t//endPrefixMapping and startPrefixMapping have not any help for dom builder\n\t//localNSMap = null\n\tif(el.closed){\n\t\tdomBuilder.endElement(ns,localName,tagName);\n\t\tif(localNSMap){\n\t\t\tfor (prefix in localNSMap) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n\t\t\t\t\tdomBuilder.endPrefixMapping(prefix);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tel.currentNSMap = currentNSMap;\n\t\tel.localNSMap = localNSMap;\n\t\t//parseStack.push(el);\n\t\treturn true;\n\t}\n}\nfunction parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){\n\tif(/^(?:script|textarea)$/i.test(tagName)){\n\t\tvar elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);\n\t\tvar text = source.substring(elStartEnd+1,elEndStart);\n\t\tif(/[&<]/.test(text)){\n\t\t\tif(/^script$/i.test(tagName)){\n\t\t\t\t//if(!/\\]\\]>/.test(text)){\n\t\t\t\t\t//lexHandler.startCDATA();\n\t\t\t\t\tdomBuilder.characters(text,0,text.length);\n\t\t\t\t\t//lexHandler.endCDATA();\n\t\t\t\t\treturn elEndStart;\n\t\t\t\t//}\n\t\t\t}//}else{//text area\n\t\t\t\ttext = text.replace(/&#?\\w+;/g,entityReplacer);\n\t\t\t\tdomBuilder.characters(text,0,text.length);\n\t\t\t\treturn elEndStart;\n\t\t\t//}\n\t\t\t\n\t\t}\n\t}\n\treturn elStartEnd+1;\n}\nfunction fixSelfClosed(source,elStartEnd,tagName,closeMap){\n\t//if(tagName in closeMap){\n\tvar pos = closeMap[tagName];\n\tif(pos == null){\n\t\t//console.log(tagName)\n\t\tpos =  source.lastIndexOf('</'+tagName+'>')\n\t\tif(pos<elStartEnd){//忘记闭合\n\t\t\tpos = source.lastIndexOf('</'+tagName)\n\t\t}\n\t\tcloseMap[tagName] =pos\n\t}\n\treturn pos<elStartEnd;\n\t//} \n}\n\nfunction _copy (source, target) {\n\tfor (var n in source) {\n\t\tif (Object.prototype.hasOwnProperty.call(source, n)) {\n\t\t\ttarget[n] = source[n];\n\t\t}\n\t}\n}\n\nfunction parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'\n\tvar next= source.charAt(start+2)\n\tswitch(next){\n\tcase '-':\n\t\tif(source.charAt(start + 3) === '-'){\n\t\t\tvar end = source.indexOf('-->',start+4);\n\t\t\t//append comment source.substring(4,end)//<!--\n\t\t\tif(end>start){\n\t\t\t\tdomBuilder.comment(source,start+4,end-start-4);\n\t\t\t\treturn end+3;\n\t\t\t}else{\n\t\t\t\terrorHandler.error(\"Unclosed comment\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}else{\n\t\t\t//error\n\t\t\treturn -1;\n\t\t}\n\tdefault:\n\t\tif(source.substr(start+3,6) == 'CDATA['){\n\t\t\tvar end = source.indexOf(']]>',start+9);\n\t\t\tdomBuilder.startCDATA();\n\t\t\tdomBuilder.characters(source,start+9,end-start-9);\n\t\t\tdomBuilder.endCDATA() \n\t\t\treturn end+3;\n\t\t}\n\t\t//<!DOCTYPE\n\t\t//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \n\t\tvar matchs = split(source,start);\n\t\tvar len = matchs.length;\n\t\tif(len>1 && /!doctype/i.test(matchs[0][0])){\n\t\t\tvar name = matchs[1][0];\n\t\t\tvar pubid = false;\n\t\t\tvar sysid = false;\n\t\t\tif(len>3){\n\t\t\t\tif(/^public$/i.test(matchs[2][0])){\n\t\t\t\t\tpubid = matchs[3][0];\n\t\t\t\t\tsysid = len>4 && matchs[4][0];\n\t\t\t\t}else if(/^system$/i.test(matchs[2][0])){\n\t\t\t\t\tsysid = matchs[3][0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lastMatch = matchs[len-1]\n\t\t\tdomBuilder.startDTD(name, pubid, sysid);\n\t\t\tdomBuilder.endDTD();\n\t\t\t\n\t\t\treturn lastMatch.index+lastMatch[0].length\n\t\t}\n\t}\n\treturn -1;\n}\n\n\n\nfunction parseInstruction(source,start,domBuilder){\n\tvar end = source.indexOf('?>',start);\n\tif(end){\n\t\tvar match = source.substring(start,end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n\t\tif(match){\n\t\t\tvar len = match[0].length;\n\t\t\tdomBuilder.processingInstruction(match[1], match[2]) ;\n\t\t\treturn end+2;\n\t\t}else{//error\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction ElementAttributes(){\n\tthis.attributeNames = {}\n}\nElementAttributes.prototype = {\n\tsetTagName:function(tagName){\n\t\tif(!tagNamePattern.test(tagName)){\n\t\t\tthrow new Error('invalid tagName:'+tagName)\n\t\t}\n\t\tthis.tagName = tagName\n\t},\n\taddValue:function(qName, value, offset) {\n\t\tif(!tagNamePattern.test(qName)){\n\t\t\tthrow new Error('invalid attribute:'+qName)\n\t\t}\n\t\tthis.attributeNames[qName] = this.length;\n\t\tthis[this.length++] = {qName:qName,value:value,offset:offset}\n\t},\n\tlength:0,\n\tgetLocalName:function(i){return this[i].localName},\n\tgetLocator:function(i){return this[i].locator},\n\tgetQName:function(i){return this[i].qName},\n\tgetURI:function(i){return this[i].uri},\n\tgetValue:function(i){return this[i].value}\n//\t,getIndex:function(uri, localName)){\n//\t\tif(localName){\n//\t\t\t\n//\t\t}else{\n//\t\t\tvar qName = uri\n//\t\t}\n//\t},\n//\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n//\tgetType:function(uri,localName){}\n//\tgetType:function(i){},\n}\n\n\n\nfunction split(source,start){\n\tvar match;\n\tvar buf = [];\n\tvar reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n\treg.lastIndex = start;\n\treg.exec(source);//skip <\n\twhile(match = reg.exec(source)){\n\t\tbuf.push(match);\n\t\tif(match[1])return buf;\n\t}\n}\n\nexports.XMLReader = XMLReader;\nexports.ParseError = ParseError;\n"]},"metadata":{},"sourceType":"script"}